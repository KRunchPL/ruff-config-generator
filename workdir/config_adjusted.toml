# A list of allowed "confusable" Unicode characters to ignore when
# enforcing RUF001, RUF002, and RUF003.
allowed-confusables = []
# A list of builtins to treat as defined references, in addition to the
# system builtins.
builtins = []
# A path to the cache directory.
# By default, Ruff stores cache results in a .ruff_cache directory in
# the current project root.
# However, Ruff will also respect the RUFF_CACHE_DIR environment
# variable, which takes precedence over that default.
# This setting will override even the RUFF_CACHE_DIR environment
# variable, if set.
cache-dir = ".ruff_cache"
# A regular expression used to identify "dummy" variables, or those which
# should be ignored when enforcing (e.g.) unused-variable rules. The
# default expression matches _, __, and _var, but not _var_.
dummy-variable-rgx = "^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$"
# A list of file patterns to exclude from formatting and linting.
# Exclusions are based on globs, and can be either:
# - Single-path patterns, like .mypy_cache (to exclude any directory
#   named .mypy_cache in the tree), foo.py (to exclude any file named
#   foo.py), or foo_*.py (to exclude any file matching foo_*.py ).
# - Relative patterns, like directory/foo.py (to exclude that specific
#   file) or directory/*.py (to exclude any Python files in
#   directory). Note that these paths are relative to the project root
#   (e.g., the directory containing your pyproject.toml).
# For more information on the glob syntax, refer to the globset documentation.
# Note that you'll typically want to use
# extend-exclude to modify the excluded paths.
exclude = [
    ".bzr",
    ".direnv",
    ".eggs",
    ".git",
    ".git-rewrite",
    ".hg",
    ".mypy_cache",
    ".nox",
    ".pants.d",
    ".pytype",
    ".ruff_cache",
    ".svn",
    ".tox",
    ".venv",
    "__pypackages__",
    "_build",
    "buck-out",
    "build",
    "dist",
    "node_modules",
    "venv",
]
# Whether to require exact codes to select preview rules. When enabled,
# preview rules will not be selected by prefixes — the full code of each
# preview rule will be required to enable the rule.
explicit-preview-rules = false
# A path to a local pyproject.toml file to merge into this
# configuration. User home directory and environment variables will be
# expanded.
# To resolve the current pyproject.toml file, Ruff will first resolve
# this base configuration file, then merge in any properties defined
# in the current configuration file.
#extend =
# A list of file patterns to omit from formatting and linting, in addition to those
# specified by exclude.
# Exclusions are based on globs, and can be either:
# - Single-path patterns, like .mypy_cache (to exclude any directory
#   named .mypy_cache in the tree), foo.py (to exclude any file named
#   foo.py), or foo_*.py (to exclude any file matching foo_*.py ).
# - Relative patterns, like directory/foo.py (to exclude that specific
#   file) or directory/*.py (to exclude any Python files in
#   directory). Note that these paths are relative to the project root
#   (e.g., the directory containing your pyproject.toml).
# For more information on the glob syntax, refer to the globset documentation.
extend-exclude = []
# A list of rule codes or prefixes to consider fixable, in addition to those
# specified by fixable.
extend-fixable = []
# A list of file patterns to include when linting, in addition to those
# specified by include.
# Inclusion are based on globs, and should be single-path patterns, like
# *.pyw, to include any file with the .pyw extension.
# For more information on the glob syntax, refer to the globset documentation.
extend-include = []
# A list of mappings from file pattern to rule codes or prefixes to
# exclude, in addition to any rules excluded by per-file-ignores.
extend-per-file-ignores = {}
# A list of rule codes or prefixes for which unsafe fixes should be considered
# safe.
extend-safe-fixes = []
# A list of rule codes or prefixes to enable, in addition to those
# specified by select.
extend-select = []
# A list of rule codes or prefixes for which safe fixes should be considered
# unsafe.
extend-unsafe-fixes = []
# A list of rule codes or prefixes that are unsupported by Ruff, but should be
# preserved when (e.g.) validating # noqa directives. Useful for
# retaining # noqa directives that cover plugins not yet implemented
# by Ruff.
external = []
# Enable fix behavior by-default when running ruff (overridden
# by the --fix and --no-fix command-line flags).
# Only includes automatic fixes unless --unsafe-fixes is provided.
fix = false
# Like fix, but disables reporting on leftover violation. Implies fix.
fix-only = false
# A list of rule codes or prefixes to consider fixable. By default,
# all rules are considered fixable.
fixable = [
    "ALL",
]
# Whether to enforce exclude and extend-exclude patterns, even for
# paths that are passed to Ruff explicitly. Typically, Ruff will lint
# any paths passed in directly, even if they would typically be
# excluded. Setting force-exclude = true will cause Ruff to
# respect these exclusions unequivocally.
# This is useful for pre-commit, which explicitly passes all
# changed files to the ruff-pre-commit
# plugin, regardless of whether they're marked as excluded by Ruff's own
# settings.
force-exclude = false
# A list of rule codes or prefixes to ignore. Prefixes can specify exact
# rules (like F841), entire categories (like F), or anything in
# between.
# When breaking ties between enabled and disabled rules (via select and
# ignore, respectively), more specific prefixes override less
# specific prefixes.
ignore = [
    "ANN101",  # Missing type annotation for `self` in method
    "ANN102",  # Missing type annotation for `cls` in classmethod
    "B005",    # Using .strip() with multi-character strings is misleading
    "D100",    # Missing docstring in public module
    "D104",    # Missing docstring in public package
    "D105",    # Missing docstring in magic method
    "D107",    # Missing docstring in `__init__`
    "D200",    # One-line docstring should fit on one line
    "D203",    # 1 blank line required before class docstring
    "D212",    # Multi-line docstring summary should start at the first line
    "RUF012",  # Mutable class attributes should be annotated with `typing.ClassVar`
    "S101",    # Use of `assert` detected
    "TCH001",  # [*] Move application import into a type-checking block
    "TCH002",  # [*] Move third-party import into a type-checking block
    "TCH003",  # [*] Move standard library import into a type-checking block
    "PYI041",  # Use `float` instead of `int | float`
]
# Avoid automatically removing unused imports in __init__.py files. Such
# imports will still be flagged, but with a dedicated message suggesting
# that the import is either added to the module's __all__ symbol, or
# re-exported with a redundant alias (e.g., import os as os).
ignore-init-module-imports = false
# A list of file patterns to include when linting.
# Inclusion are based on globs, and should be single-path patterns, like
# *.pyw, to include any file with the .pyw extension. pyproject.toml is
# included here not for configuration but because we lint whether e.g. the
# [project] matches the schema.
# For more information on the glob syntax, refer to the globset documentation.
include = [
    "*.py",
    "*.pyi",
    "**/pyproject.toml",
]
# The number of spaces per indentation level (tab).
# Used by the formatter and when enforcing long-line violations (like E501) to determine the visual
# width of a tab.
# This option changes the number of spaces the formatter inserts when
# using soft-tabs (indent-style = space).
# PEP 8 recommends using 4 spaces per indentation level.
indent-width = 4
# The line length to use when enforcing long-lines violations (like E501)
# and at which isort and the formatter prefers to wrap lines.
# The length is determined by the number of characters per line, except for lines containing East Asian characters or emojis.
# For these lines, the unicode width of each character is added up to determine the length.
# The value must be greater than 0 and less than or equal to 320.
# Note: While the formatter will attempt to format lines such that they remain
# within the line-length, it isn't a hard upper bound, and formatted lines may
# exceed the line-length.
# See pycodestyle.max-line-length to configure different lengths for E501 and the formatter.
line-length = 110
# A list of objects that should be treated equivalently to a
# logging.Logger object.
# This is useful for ensuring proper diagnostics (e.g., to identify
# logging deprecations and other best-practices) for projects that
# re-export a logging.Logger object from a common module.
# For example, if you have a module logging_setup.py with the following
# contents:
# import logging
#
# logger = logging.getLogger(__name__)
# Adding "logging_setup.logger" to logger-objects will ensure that
# logging_setup.logger is treated as a logging.Logger object when
# imported from other modules (e.g., from logging_setup import logger).
logger-objects = []
# Mark the specified directories as namespace packages. For the purpose of
# module resolution, Ruff will treat those directories as if they
# contained an __init__.py file.
namespace-packages = []
# The style in which violation messages should be formatted: "text"
# (default), "grouped" (group messages by file), "json"
# (machine-readable), "junit" (machine-readable XML), "github" (GitHub
# Actions annotations), "gitlab" (GitLab CI code quality report),
# "pylint" (Pylint text format) or "azure" (Azure Pipeline logging commands).
output-format = "text"
# Whether to enable preview mode. When preview mode is enabled, Ruff will
# use unstable rules, fixes, and formatting.
preview = false
# Require a specific version of Ruff to be running (useful for unifying
# results across many environments, e.g., with a pyproject.toml
# file).
#required-version =
# Whether to automatically exclude files that are ignored by .ignore,
# .gitignore, .git/info/exclude, and global gitignore files.
# Enabled by default.
respect-gitignore = true
# A list of rule codes or prefixes to enable. Prefixes can specify exact
# rules (like F841), entire categories (like F), or anything in
# between.
# When breaking ties between enabled and disabled rules (via select and
# ignore, respectively), more specific prefixes override less
# specific prefixes.
select = [
    "ALL",
]
# Whether to show an enumeration of all fixed lint violations
# (overridden by the --show-fixes command-line flag).
show-fixes = false
# Whether to show source code snippets when reporting lint violations
# (overridden by the --show-source command-line flag).
show-source = false
# The directories to consider when resolving first- vs. third-party
# imports.
# As an example: given a Python package structure like:
# ---
# my_project
# ├── pyproject.toml
# └── src
#     └── my_package
#         ├── __init__.py
#         ├── foo.py
#         └── bar.py
# ---
# The ./src directory should be included in the src option
# (e.g., src = ["src"]), such that when resolving imports,
# my_package.foo is considered a first-party import.
# When omitted, the src directory will typically default to the
# directory containing the nearest pyproject.toml, ruff.toml, or
# .ruff.toml file (the "project root"), unless a configuration file
# is explicitly provided (e.g., via the --config command-line flag).
# This field supports globs. For example, if you have a series of Python
# packages in a python_modules directory, src = ["python_modules/*"]
# would expand to incorporate all of the packages in that directory. User
# home directory and environment variables will also be expanded.
src = [
    ".",
]
# The minimum Python version to target, e.g., when considering automatic
# code upgrades, like rewriting type annotations. Ruff will not propose
# changes using features that are not available in the given version.
# For example, to represent supporting Python >=3.10 or ==3.10
# specify target-version = "py310".
# If omitted, and Ruff is configured via a pyproject.toml file, the
# target version will be inferred from its project.requires-python
# field (e.g., requires-python = ">=3.8"). If Ruff is configured via
# ruff.toml or .ruff.toml, no such inference will be performed.
target-version = "py311"
# A list of task tags to recognize (e.g., "TODO", "FIXME", "XXX").
# Comments starting with these tags will be ignored by commented-out code
# detection (ERA), and skipped by line-length rules (E501) if
# ignore-overlong-task-comments is set to true.
task-tags = [
    "TODO",
    "FIXME",
    "XXX",
]
# A list of modules whose exports should be treated equivalently to
# members of the typing module.
# This is useful for ensuring proper type annotation inference for
# projects that re-export typing and typing_extensions members
# from a compatibility module. If omitted, any members imported from
# modules apart from typing and typing_extensions will be treated
# as ordinary Python objects.
typing-modules = []
# A list of rule codes or prefixes to consider non-fixable.
unfixable = []
# Enable application of unsafe fixes.
unsafe-fixes = false
# A list of mappings from file pattern to rule codes or prefixes to
# exclude, when considering any matching files.
[per-file-ignores]
"tests/*" = [
    "ANN",  # flake8-annotations
    "SLF001",  # Private member accessed
    "FBT001",  # Boolean-typed positional argument in function definition
    "PLR0913",  # Too many arguments to function call
]
"tests/**/test_*" = [
    "D101",  # Missing docstring in public class
    "D103",  # Missing docstring in public function
    "B011",  # [*] Do not `assert False` (`python -O` removes these calls), raise `AssertionError()`
]

[flake8-annotations]
# Whether to suppress ANN401 for dynamically typed *args and
# **kwargs arguments.
allow-star-arg-any = false
# Whether to suppress ANN* rules for any declaration
# that hasn't been typed at all.
# This makes it easier to gradually add types to a codebase.
ignore-fully-untyped = false
# Whether to allow the omission of a return type hint for __init__ if at
# least one argument is annotated.
mypy-init-return = false
# Whether to suppress ANN000-level violations for arguments matching the
# "dummy" variable regex (like _).
suppress-dummy-args = false
# Whether to suppress ANN200-level violations for functions that meet
# either of the following criteria:
# - Contain no return statement.
# - Explicit return statement(s) all return None (explicitly or
#   implicitly).
suppress-none-returning = false

[flake8-bandit]
# Whether to disallow try-except-pass (S110) for specific
# exception types. By default, try-except-pass is only
# disallowed for Exception and BaseException.
check-typed-exception = false
# A list of directories to consider temporary.
hardcoded-tmp-directory = [
    "/tmp",
    "/var/tmp",
    "/dev/shm",
]
# A list of directories to consider temporary, in addition to those
# specified by hardcoded-tmp-directory.
hardcoded-tmp-directory-extend = []

[flake8-bugbear]
# Additional callable functions to consider "immutable" when evaluating, e.g., the
# function-call-in-default-argument rule (B008) or function-call-in-dataclass-defaults
# rule (RUF009).
# Expects to receive a list of fully-qualified names (e.g., fastapi.Query, rather than
# Query).
extend-immutable-calls = []

[flake8-builtins]
# Ignore list of builtins.
builtins-ignorelist = [
    'id',
]

[flake8-comprehensions]
# Allow dict calls that make use of keyword arguments (e.g., dict(a=1, b=2)).
allow-dict-calls-with-keyword-arguments = false

[flake8-copyright]
# Author to enforce within the copyright notice. If provided, the
# author must be present immediately following the copyright notice.
#author =
# A minimum file size (in bytes) required for a copyright notice to
# be enforced. By default, all files are validated.
min-file-size = 0
# The regular expression used to match the copyright notice, compiled
# with the regex crate.
# Defaults to (?i)Copyright\s+(\(C\)\s+)?\d{4}(-\d{4})*, which matches
# the following:
# - Copyright 2023
# - Copyright (C) 2023
# - Copyright 2021-2023
# - Copyright (C) 2021-2023
notice-rgx = "(?i)Copyright\\s+(\\(C\\)\\s+)?\\d{4}([-,]\\d{4})*"

[flake8-errmsg]
# Maximum string length for string literals in exception messages.
max-string-length = 0

[flake8-gettext]
# Additional function names to consider as internationalization calls, in addition to those
# included in function-names.
extend-function-names = []
# The function names to consider as internationalization calls.
function-names = [
    "_",
    "gettext",
    "ngettext",
]

[flake8-implicit-str-concat]
# Whether to allow implicit string concatenations for multiline strings.
# By default, implicit concatenations of multiline strings are
# allowed (but continuation lines, delimited with a backslash, are
# prohibited).
# Note that setting allow-multiline = false should typically be coupled
# with disabling explicit-string-concatenation (ISC003). Otherwise,
# both explicit and implicit multiline string concatenations will be seen
# as violations.
allow-multiline = true

[flake8-import-conventions]
# A mapping from module to its banned import aliases.
banned-aliases = {}
# A list of modules that should not be imported from using the
# from ... import ... syntax.
# For example, given banned-from = ["pandas"], from pandas import DataFrame
# would be disallowed, while import pandas would be allowed.
banned-from = [
    "yaml",
    "json",
]
# A mapping from module to conventional import alias. These aliases will
# be added to the aliases mapping.
extend-aliases = {}

# The conventional aliases for imports. These aliases can be extended by
# the extend_aliases option.
[flake8-import-conventions.aliases]
"altair" = "alt"
"matplotlib" = "mpl"
"matplotlib.pyplot" = "plt"
"numpy" = "np"
"pandas" = "pd"
"seaborn" = "sns"
"tensorflow" = "tf"
"tkinter" =  "tk"
"holoviews" = "hv"
"panel" = "pn"
"plotly.express" = "px"
"polars" = "pl"
"pyarrow" = "pa"

[flake8-pytest-style]
# Boolean flag specifying whether @pytest.fixture() without parameters
# should have parentheses. If the option is set to true (the
# default), @pytest.fixture() is valid and @pytest.fixture is
# invalid. If set to false, @pytest.fixture is valid and
# @pytest.fixture() is invalid.
fixture-parentheses = false
# Boolean flag specifying whether @pytest.mark.foo() without parameters
# should have parentheses. If the option is set to true (the
# default), @pytest.mark.foo() is valid and @pytest.mark.foo is
# invalid. If set to false, @pytest.fixture is valid and
# @pytest.mark.foo() is invalid.
mark-parentheses = false
# Expected type for multiple argument names in @pytest.mark.parametrize.
# The following values are supported:
# - csv — a comma-separated list, e.g.
#   @pytest.mark.parametrize('name1,name2', ...)
# - tuple (default) — e.g.
#   @pytest.mark.parametrize(('name1', 'name2'), ...)
# - list — e.g. @pytest.mark.parametrize(['name1', 'name2'], ...)
parametrize-names-type = "list"
# Expected type for each row of values in @pytest.mark.parametrize in
# case of multiple parameters. The following values are supported:
# - tuple (default) — e.g.
#   @pytest.mark.parametrize(('name1', 'name2'), [(1, 2), (3, 4)])
# - list — e.g.
#   @pytest.mark.parametrize(('name1', 'name2'), [[1, 2], [3, 4]])
parametrize-values-row-type = "tuple"
# Expected type for the list of values rows in @pytest.mark.parametrize.
# The following values are supported:
# - tuple — e.g. @pytest.mark.parametrize('name', (1, 2, 3))
# - list (default) — e.g. @pytest.mark.parametrize('name', [1, 2, 3])
parametrize-values-type = "list"
# List of additional exception names that require a match= parameter in a
# pytest.raises() call. This extends the default list of exceptions
# that require a match= parameter.
# This option is useful if you want to extend the default list of
# exceptions that require a match= parameter without having to specify
# the entire list.
# Note that this option does not remove any exceptions from the default
# list.
# Supports glob patterns. For more information on the glob syntax, refer
# to the globset documentation.
raises-extend-require-match-for = []
# List of exception names that require a match= parameter in a
# pytest.raises() call.
# Supports glob patterns. For more information on the glob syntax, refer
# to the globset documentation.
raises-require-match-for = [
    "BaseException",
    "Exception",
    "ValueError",
    "OSError",
    "IOError",
    "EnvironmentError",
    "socket.error",
]

[flake8-quotes]
# Whether to avoid using single quotes if a string contains single quotes,
# or vice-versa with double quotes, as per PEP 8.
# This minimizes the need to escape quotation marks within strings.
avoid-escape = true
# Quote style to prefer for docstrings (either "single" or "double").
# When using the formatter, only "double" is compatible, as the formatter
# enforces double quotes for docstrings strings.
docstring-quotes = "double"
# Quote style to prefer for inline strings (either "single" or
# "double").
# When using the formatter, ensure that format.quote-style is set to
# the same preferred quote style.
inline-quotes = "single"
# Quote style to prefer for multiline strings (either "single" or
# "double").
# When using the formatter, only "double" is compatible, as the formatter
# enforces double quotes for multiline strings.
multiline-quotes = "double"

[flake8-self]
# Additional names to ignore when considering flake8-self violations,
# in addition to those included in ignore-names.
extend-ignore-names = []
# A list of names to ignore when considering flake8-self violations.
ignore-names = [
    "_make",
    "_asdict",
    "_replace",
    "_fields",
    "_field_defaults",
    "_name_",
    "_value_",
]

[flake8-tidy-imports]
# Whether to ban all relative imports ("all"), or only those imports
# that extend into the parent module or beyond ("parents").
ban-relative-imports = "parents"
# Specific modules or module members that may not be imported or accessed.
# Note that this rule is only meant to flag accidental uses,
# and can be circumvented via eval or importlib.
banned-api = {}
# List of specific modules that may not be imported at module level, and should instead be
# imported lazily (e.g., within a function definition, or an if TYPE_CHECKING:
# block, or some other nested context).
banned-module-level-imports = []

[flake8-type-checking]
# Exempt certain modules from needing to be moved into type-checking
# blocks.
exempt-modules = [
    "typing",
]
# Exempt classes that list any of the enumerated classes as a base class
# from needing to be moved into type-checking blocks.
# Common examples include Pydantic's pydantic.BaseModel and SQLAlchemy's
# sqlalchemy.orm.DeclarativeBase, but can also support user-defined
# classes that inherit from those base classes. For example, if you define
# a common DeclarativeBase subclass that's used throughout your project
# (e.g., class Base(DeclarativeBase) ... in base.py), you can add it to
# this list (runtime-evaluated-base-classes = ["base.Base"]) to exempt
# models from being moved into type-checking blocks.
runtime-evaluated-base-classes = []
# Exempt classes decorated with any of the enumerated decorators from
# needing to be moved into type-checking blocks.
runtime-evaluated-decorators = []
# Enforce TC001, TC002, and TC003 rules even when valid runtime imports
# are present for the same module.
# See flake8-type-checking's strict option.
strict = false

[flake8-unused-arguments]
# Whether to allow unused variadic arguments, like *args and **kwargs.
ignore-variadic-names = false

[format]
# A list of file patterns to exclude from formatting in addition to the files excluded globally (see exclude, and extend-exclude).
# Exclusions are based on globs, and can be either:
# - Single-path patterns, like .mypy_cache (to exclude any directory
#   named .mypy_cache in the tree), foo.py (to exclude any file named
#   foo.py), or foo_*.py (to exclude any file matching foo_*.py ).
# - Relative patterns, like directory/foo.py (to exclude that specific
#   file) or directory/*.py (to exclude any Python files in
#   directory). Note that these paths are relative to the project root
#   (e.g., the directory containing your pyproject.toml).
# For more information on the glob syntax, refer to the globset documentation.
# Note that you'll typically want to use
# extend-exclude to modify the excluded paths.
exclude = []
# Whether to use spaces or tabs for indentation.
# indent-style = "space" (default):
# ---
# def f():
#     print("Hello") #  Spaces indent the `print` statement.
# ---
# indent-style = "tab"":
# ---
# def f():
#     print("Hello") #  A tab `\t` indents the `print` statement.
# ---
# PEP 8 recommends using spaces for indentation.
# We care about accessibility; if you do not need tabs for accessibility, we do not recommend you use them.
# See indent-width to configure the number of spaces per indentation and the tab width.
indent-style = "space"
# The character Ruff uses at the end of a line.
# - auto: The newline style is detected automatically on a file per file basis. Files with mixed line endings will be converted to the first detected line ending. Defaults to \n for files that contain no line endings.
# - lf: Line endings will be converted to \n. The default line ending on Unix.
# - cr-lf: Line endings will be converted to \r\n. The default line ending on Windows.
# - native: Line endings will be converted to \n on Unix and \r\n on Windows.
line-ending = "lf"
# Whether to enable the unstable preview style formatting.
preview = false
# Whether to prefer single ' or double " quotes for strings. Defaults to double quotes.
# In compliance with PEP 8 and PEP 257,
# Ruff prefers double quotes for multiline strings and docstrings, regardless of the
# configured quote style.
# Ruff may also deviate from this option if using the configured quotes would require
# escaping quote characters within the string. For example, given:
# ---
# a = "a string without any quotes"
# b = "It's monday morning"
# ---
# Ruff will change a to use single quotes when using quote-style = "single". However,
# b will be unchanged, as converting to single quotes would require the inner ' to be
# escaped, which leads to less readable code: 'It\'s monday morning'.
quote-style = "single"
# Ruff uses existing trailing commas as an indication that short lines should be left separate.
# If this option is set to true, the magic trailing comma is ignored.
# For example, Ruff leaves the arguments separate even though
# collapsing the arguments to a single line doesn't exceed the line length if skip-magic-trailing-comma = false:
# ---
#  # The arguments remain on separate lines because of the trailing comma after `b`
# def test(
#     a,
#     b,
# ): pass
# ---
# Setting skip-magic-trailing-comma = true changes the formatting to:
# ---
# # The arguments remain on separate lines because of the trailing comma after `b`
# def test(a, b):
#     pass
# ---
skip-magic-trailing-comma = false

[isort]
# Sort imports taking into account case sensitivity.
case-sensitive = false
# An override list of tokens to always recognize as a Class for
# order-by-type regardless of casing.
classes = []
# Combines as imports on the same line. See isort's combine-as-imports
# option.
combine-as-imports = true
# An override list of tokens to always recognize as a CONSTANT
# for order-by-type regardless of casing.
constants = []
# Whether to automatically mark imports from within the same package as first-party.
# For example, when detect-same-package = true, then when analyzing files within the
# foo package, any imports from within the foo package will be considered first-party.
# This heuristic is often unnecessary when src is configured to detect all first-party
# sources; however, if src is not configured, this heuristic can be useful to detect
# first-party imports from within (but not across) first-party packages.
detect-same-package = true
# A list of modules to consider standard-library, in addition to those
# known to Ruff in advance.
# Supports glob patterns. For more information on the glob syntax, refer
# to the globset documentation.
extra-standard-library = []
# Forces all from imports to appear on their own line.
force-single-line = false
# Don't sort straight-style imports (like import sys) before from-style
# imports (like from itertools import groupby). Instead, sort the
# imports by module, independent of import style.
force-sort-within-sections = false
# Force specific imports to the top of their appropriate section.
force-to-top = []
# Force import from statements with multiple members and at least one
# alias (e.g., import A as B) to wrap such that every line contains
# exactly one member. For example, this formatting would be retained,
# rather than condensing to a single line:
# ---
# from .utils import (
#     test_directory as test_directory,
#     test_id as test_id
# )
# ---
# Note that this setting is only effective when combined with
# combine-as-imports = true. When combine-as-imports isn't
# enabled, every aliased import from will be given its own line, in
# which case, wrapping is not necessary.
# When using the formatter, ensure that format.skip-magic-trailing-comma is set to false (default)
# when enabling force-wrap-aliases to avoid that the formatter collapses members if they all fit on a single line.
force-wrap-aliases = false
# A list of modules to separate into auxiliary block(s) of imports,
# in the order specified.
forced-separate = []
# A list of modules to consider first-party, regardless of whether they
# can be identified as such via introspection of the local filesystem.
# Supports glob patterns. For more information on the glob syntax, refer
# to the globset documentation.
known-first-party = []
# A list of modules to consider being a local folder.
# Generally, this is reserved for relative imports (from . import module).
# Supports glob patterns. For more information on the glob syntax, refer
# to the globset documentation.
known-local-folder = []
# A list of modules to consider third-party, regardless of whether they
# can be identified as such via introspection of the local filesystem.
# Supports glob patterns. For more information on the glob syntax, refer
# to the globset documentation.
known-third-party = []
# The number of blank lines to place after imports.
# Use -1 for automatic determination.
# When using the formatter, only the values -1, 1, and 2 are compatible because
# it enforces at least one empty and at most two empty lines after imports.
lines-after-imports = 2
# The number of lines to place between "direct" and import from imports.
# When using the formatter, only the values 0 and 1 are compatible because
# it preserves up to one empty line after imports in nested blocks.
lines-between-types = 0
# A list of sections that should not be delineated from the previous
# section via empty lines.
no-lines-before = []
# Order imports by type, which is determined by case, in addition to
# alphabetically.
order-by-type = false
# Whether to place "closer" imports (fewer . characters, most local)
# before "further" imports (more . characters, least local), or vice
# versa.
# The default ("furthest-to-closest") is equivalent to isort's
# reverse-relative default (reverse-relative = false); setting
# this to "closest-to-furthest" is equivalent to isort's
# reverse-relative = true.
relative-imports-order = "furthest-to-closest"
# Add the specified import line to all files.
required-imports = []
# Override in which order the sections should be output. Can be used to move custom sections.
section-order = [
    "future",
    "standard-library",
    "third-party",
    "first-party",
    "local-folder",
]
# A list of mappings from section names to modules.
# By default custom sections are output last, but this can be overridden with section-order.
sections = {}
# One or more modules to exclude from the single line rule.
single-line-exclusions = []
# If a comma is placed after the last member in a multi-line import, then
# the imports will never be folded into one line.
# See isort's split-on-trailing-comma option.
# When using the formatter, ensure that format.skip-magic-trailing-comma is set to false (default) when enabling split-on-trailing-comma
# to avoid that the formatter removes the trailing commas.
split-on-trailing-comma = true
# An override list of tokens to always recognize as a var
# for order-by-type regardless of casing.
variables = []

[mccabe]
# The maximum McCabe complexity to allow before triggering C901 errors.
max-complexity = 10

[pep8-naming]
# A list of decorators that, when applied to a method, indicate that the
# method should be treated as a class method (in addition to the builtin
# @classmethod).
# For example, Ruff will expect that any method decorated by a decorator
# in this list takes a cls argument as its first argument.
# Expects to receive a list of fully-qualified names (e.g., pydantic.validator,
# rather than validator).
classmethod-decorators = [
    "pydantic.validator",
    "pydantic.root_validator",
    "sqlalchemy.orm.declared_attr",
    "sqlalchemy.ext.declarative.declared_attr",
]
# Additional names (or patterns) to ignore when considering pep8-naming violations,
# in addition to those included in ignore-names
# Supports glob patterns. For example, to ignore all names starting with
# or ending with _test, you could use ignore-names = ["test_*", "*_test"].
# For more information on the glob syntax, refer to the globset documentation.
extend-ignore-names = []
# A list of names (or patterns) to ignore when considering pep8-naming violations.
# Supports glob patterns. For example, to ignore all names starting with
# or ending with _test, you could use ignore-names = ["test_*", "*_test"].
# For more information on the glob syntax, refer to the globset documentation.
ignore-names = [
    "setUp",
    "tearDown",
    "setUpClass",
    "tearDownClass",
    "setUpModule",
    "tearDownModule",
    "asyncSetUp",
    "asyncTearDown",
    "setUpTestData",
    "failureException",
    "longMessage",
    "maxDiff",
    "getLogger",
]
# A list of decorators that, when applied to a method, indicate that the
# method should be treated as a static method (in addition to the builtin
# @staticmethod).
# For example, Ruff will expect that any method decorated by a decorator
# in this list has no self or cls argument.
# Expects to receive a list of fully-qualified names (e.g., belay.Device.teardown,
# rather than teardown).
staticmethod-decorators = []

[pycodestyle]
# Whether line-length violations (E501) should be triggered for
# comments starting with task-tags (by default: ["TODO", "FIXME",
# and "XXX"]).
ignore-overlong-task-comments = false
# The maximum line length to allow for doc-line-too-long violations within
# documentation (W505), including standalone comments. By default,
# this is set to null which disables reporting violations.
# The length is determined by the number of characters per line, except for lines containing Asian characters or emojis.
# For these lines, the unicode width of each character is added up to determine the length.
# See the doc-line-too-long rule for more information.
max-doc-length = 110
# The maximum line length to allow for line-too-long violations. By default,
# this is set to the value of the line-length option.
# Use this option when you want to detect extra-long lines that the formatter can't automatically split by setting
# pycodestyle.line-length to a value larger than line-length.
# ---
# line-length = 88 # The formatter wraps lines at a length of 88
#
# [pycodestyle]
# max-line-length = 100 # E501 reports lines that exceed the length of 100.
# ---
# The length is determined by the number of characters per line, except for lines containing East Asian characters or emojis.
# For these lines, the unicode width of each character is added up to determine the length.
# See the line-too-long rule for more information.
#max-line-length =

[pydocstyle]
# Whether to use Google-style or NumPy-style conventions or the PEP 257
# defaults when analyzing docstring sections.
# Enabling a convention will force-disable any rules that are not
# included in the specified convention. As such, the intended use is
# to enable a convention and then selectively disable any additional
# rules on top of it.
# For example, to use Google-style conventions but avoid requiring
# documentation for every function parameter:
# ---
# [tool.ruff]
# # Enable all `pydocstyle` rules, limiting to those that adhere to the
# # Google convention via `convention = "google"`, below.
# select = ["D"]
#
# # On top of the Google convention, disable `D417`, which requires
# # documentation for every function parameter.
# ignore = ["D417"]
#
# [tool.ruff.pydocstyle]
# convention = "google"
# ---
# As conventions force-disable all rules not included in the convention,
# enabling additional rules on top of a convention is currently
# unsupported.
#convention =
# Ignore docstrings for functions or methods decorated with the
# specified fully-qualified decorators.
ignore-decorators = []
# A list of decorators that, when applied to a method, indicate that the
# method should be treated as a property (in addition to the builtin
# @property and standard-library @functools.cached_property).
# For example, Ruff will expect that any method decorated by a decorator
# in this list can use a non-imperative summary line.
property-decorators = []

[pyflakes]
# Additional functions or classes to consider generic, such that any
# subscripts should be treated as type annotation (e.g., ForeignKey in
# django.db.models.ForeignKey["User"].
# Expects to receive a list of fully-qualified names (e.g., django.db.models.ForeignKey,
# rather than ForeignKey).
extend-generics = []

[pylint]
# Constant types to ignore when used as "magic values" (see: PLR2004).
allow-magic-value-types = [
    "str",
    "bytes",
]
# Maximum number of arguments allowed for a function or method definition
# (see: PLR0913).
max-args = 5
# Maximum number of Boolean expressions allowed within a single if statement
# (see: PLR0916).
max-bool-expr = 5
# Maximum number of branches allowed for a function or method body (see:
# PLR0912).
max-branches = 12
# Maximum number of public methods allowed for a class (see: PLR0904).
max-public-methods = 20
# Maximum number of return statements allowed for a function or method
# body (see PLR0911)
max-returns = 6
# Maximum number of statements allowed for a function or method body (see:
# PLR0915).
max-statements = 50

[pyupgrade]
# Whether to avoid PEP 585 (List[int] -> list[int]) and PEP 604
# (Union[str, int] -> str | int) rewrites even if a file imports
# from __future__ import annotations.
# This setting is only applicable when the target Python version is below
# 3.9 and 3.10 respectively, and is most commonly used when working with
# libraries like Pydantic and FastAPI, which rely on the ability to parse
# type annotations at runtime. The use of from __future__ import annotations
# causes Python to treat the type annotations as strings, which typically
# allows for the use of language features that appear in later Python
# versions but are not yet supported by the current version (e.g., str |
# int). However, libraries that rely on runtime type annotations will
# break if the annotations are incompatible with the current Python
# version.
# For example, while the following is valid Python 3.8 code due to the
# presence of from __future__ import annotations, the use of str| int
# prior to Python 3.10 will cause Pydantic to raise a TypeError at
# runtime:
# ---
# from __future__ import annotations
#
# import pydantic
#
# class Foo(pydantic.BaseModel):
#    bar: str | int
# ---
keep-runtime-typing = false
